Metadata-Version: 2.1
Name: json-repair
Version: 0.0.1
Summary: A small package to repair broken json files. Built because GPT keeps fucking up its json response
Author-email: Stefano Baccianella <stefano.baccianella@gmail.com>
Project-URL: Homepage, https://github.com/mangiucugna/python-json-repair
Project-URL: Bug Tracker, https://github.com/mangiucugna/python-json-repair/issues
Classifier: Programming Language :: Python :: 3
Classifier: License :: OSI Approved :: MIT License
Classifier: Operating System :: OS Independent
Requires-Python: >=3.8
Description-Content-Type: text/markdown
License-File: LICENSE

Forked from https://github.com/floydw1234/fix_broken_json

This simple package can be used to repair a broken json file, particularly useful if you are using LLMs because those things keep fucking up the json output.

# How to use
    from json_repair import repair_json
    good_json_string = repair_json(bad_json_string)

# ChatGPT explanation of what this code is doing
This Python script is designed to repair a truncated JSON string. It uses a stack-based approach to keep track of the context of the JSON string as it is being parsed. Here's a step-by-step breakdown:

1. Enum Definitions: The script starts by defining two enumerations, ContextType and RespawnReason. ContextType represents the different contexts that can be encountered while parsing a JSON string, such as a string, number, array, object, etc. RespawnReason represents the reasons why the parser might need to "respawn", or start over from a certain position.

2. Whitespace Check Function: The is_whitespace function checks if a given character is a whitespace character.

3. Main Function: The untruncate_json function is the main function that repairs the truncated JSON string. It initializes a stack to keep track of the context, and several variables to keep track of the position in the string and the respawn information.

4. Helper Functions: Inside untruncate_json, several helper functions are defined. These functions manipulate the context stack and the respawn information, and determine what to do based on the current character and context.

5. Main Parsing Loop: The main loop iterates over each character in the input string. Depending on the current context and character, it performs different actions, such as pushing a new context onto the stack, popping the current context, setting or clearing the respawn information, or not consuming the current character.

6. Respawn Handling: After the main loop, if a respawn is needed, the context stack is truncated to the respawn length, and the result string is initialized with the part of the input string before the respawn position.

7. Finalization: The script then iterates over the remaining contexts in the stack in reverse order, and appends the appropriate closing characters to the result string based on the context.

8. Result: Finally, the function returns the repaired JSON string by joining the result list into a single string.

This script is quite complex and handles many edge cases. It's a good example of a state machine, where the current state (context) and input (character) determine the next state and output.
